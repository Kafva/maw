#!/usr/bin/env ruby
require 'open3'
require 'json'
require 'tempfile'
require 'yaml'
require 'fileutils'
require 'optparse'

class CommandError < StandardError
    # @return [String]
    attr_reader :program
    # @return [String]
    attr_reader :out

    # @param program [String]
    # @param out [String]
    def initialize program, out
        @program = program
        @out = out
        super("Command error '#{program}': #{out}")
    end
end

def die msg
    err msg
    exit 1
end

# @param args [Array]
def err args
    warn "\e[91m❯\e[0m #{args}"
end

# @param args [Array]
def info args
    warn "\e[92m❯\e[0m #{args}"
end

# @param args [Array]
def debug args
    return unless FLAGS[:debug]

    warn "\e[94m❯\e[0m #{args}"
end

# @param program [String]
# @param args [Array]
# @return [Process::Status]
def system_run program, args
    cmdarr = ([program] + args)
    debug cmdarr.join ' '
    _, stderr, status = Open3.capture3(*cmdarr)

    raise CommandError.new(program, stderr) unless status.success?

    status
end

# Create random unicode string
# https://en.wikipedia.org/wiki/Unicode_block
# @param minlen [Array]
# @param maxlen [Array]
def randstr minlen, maxlen
    str_len = rand minlen..maxlen
    out = ''
    (0..str_len).each do |_|
        choice = rand(0..10) % 10
        if choice.zero? # space
            out += ' '
        elsif choice < 5 # ascii
            out += (rand CHAR_RANGES[0]).chr 'utf-8'
        else # any character set
            char_range = CHAR_RANGES.sample
            out += (rand char_range).chr 'utf-8'
        end
    end
    out.gsub(%r{/}, '').gsub('\\', '\\\\')
end

# @param outputfile [String]
# @param title [String, void]
# @param album [String, void]
# @param artist [String, void]
# @param cover_color [String, void]
# @param duration [Integer, void]
def generate_audio(outputfile:,
                title: nil,
                album: nil,
                artist: nil,
                cover_color: nil,
                duration: 30)
    maxlen = 12
    maxlen_text = 32
    tmpcover = nil
    begin
        unless cover_color.nil?
            tmpcover = Tempfile.new ["maw", ".png"]
            generate_cover cover_color, tmpcover.path
        end

        system_run "ffmpeg", ["-y", "-f", "lavfi"] +
                             # Audio source
                             ["-i", "anullsrc=duration=#{duration}"] +
                             # Image source and format
                             (tmpcover.nil? ? [] : ["-i", tmpcover.path, "-c:v", "copy"]) +
                             # Audio format
                             ["-c:a", "aac", "-shortest"] +
                             # Metadata
                             ["-metadata", "title=\"#{title.nil? ? randstr(1, maxlen) : title}\"",
                             "-metadata", "album=\"#{album.nil? ? randstr(1, maxlen) : album}\"",
                             "-metadata", "artist=\"#{artist.nil? ? randstr(1, maxlen) : artist}\"",
                             "-metadata", "comment=\"#{randstr 1, maxlen_text}\"",
                             "-metadata", "description=\"#{randstr 1, maxlen_text}\"",
                             "-metadata", "genre=\"#{randstr 1, maxlen}\"",
                             "-metadata", "composer=\"#{randstr 1, maxlen}\"",
                             "-metadata", "copyright=\"#{randstr 1, maxlen}\"",
                             "-metadata", "synopsis=\"#{randstr 1, maxlen_text}\"",
                             outputfile]
    rescue Interrupt
        warn "Cancelled"
    rescue CommandError => e
        err e.out
        die "Command failed: #{e.program}"
    end
ensure
    tmpcover&.unlink
end

def generate_cover color, outputfile
    system_run "convert", ["-size", "1280x720", "xc:#{color}", outputfile]
end

def setup
    cfg_yaml = <<~HEREDOC
        art_dir: #{ART_ROOT}
        music_dir: #{MUSIC_ROOT}
        playlists:
            first:
              - red/red1.mp4
              - red/red2.mp4
            second:
              - blue/blue1.mp4
              - blue/blue2.mp4
        metadata:
            red:
              album: Red album
              artist: Red artist
              crop_cover: true
              clear_metadata: true
            blue:
              album: Blue album
              artist: Blue artist
              cover: blue.png
              clear_metadata: true
    HEREDOC

    FileUtils.mkdir_p ART_ROOT
    FileUtils.mkdir_p MUSIC_ROOT
    File.write(CFG, cfg_yaml)

    ALBUMS.each do |album|
        (1...5).each do |i|
            FileUtils.mkdir_p "#{MUSIC_ROOT}/#{album}"
            generate_cover album, "#{ART_ROOT}/#{album}.png"
            generate_audio outputfile: "#{MUSIC_ROOT}/#{album}/#{album}#{i}.mp4",
                        cover_color: album
        end
    end

    system "tree", "--noreport", "#{TOP}/music" if FLAGS[:debug]
end

## tests #######################################################################

# @return [Boolean]
def test_update
    # r = system_run AVBIN, ['-c', CFG, 'up']

    sleep 1
    r = (2 * rand).to_i % 2
    r.zero?
end

################################################################################

CHAR_RANGES = [
    (0x20..0x7f), # ascii
    (0x80..0x2af), # extended latin1
    (0x3040..0x309f), # hiragana
    (0x1f600..0x1f64f) # emoticons
].freeze

FLAGS = { # rubocop:disable Style/MutableConstant
    failfast: false,
    debug: false,
    pattern: nil
}
DEBUG = false
ALBUMS = ["red", "blue", "green", "pink"].freeze
TOP = File.dirname(__FILE__).freeze
ART_ROOT = "#{TOP}/music/art".freeze
MUSIC_ROOT = "#{TOP}/music/albums".freeze
CFG = "#{TOP}/music/maw.yml".freeze
AVBIN = File.realpath "#{TOP}/../build/maw"

parser = OptionParser.new do |opts|
    opts.banner = "usage: #{File.basename $0} [FLAGS]"
    opts.on('-d', '--debug', 'Show debug information') do |_|
        FLAGS[:debug] = true
    end
    opts.on('-f', '--fail-fast', 'Stop on first failure') do |_|
        FLAGS[:failfast] = true
    end
    opts.on('-mPATTERN', '--match=PATTERN', 'Only run tests matching pattern') do |p|
        FLAGS[:pattern] = p
    end
    opts.on('-h', '--help', 'Show help and exit') do |_|
        opts.display
        exit
    end
end

begin
    parser.parse!
rescue StandardError => e
    die e.message, parser.help
end

info "Setting up testdata..."
setup

TESTS = [
    "test_update",
    "test_update",
    "test_update",
    "test_update",
    "test_update",
    "test_update",
    "test_update",
    "test_update"
].freeze
passed = 0

info "Starting tests"

TESTS.each_with_index do |t, i|
    unless FLAGS[:pattern].nil?
        next unless t.include? FLAGS[:pattern] # rubocop:disable Style/SoleNestedConditional
    end

    if eval t # rubocop:disable Security/Eval
        passed += 1
        $stderr.print "\r\e[92m❯\e[0m [#{t}] Completed [#{i + 1}/#{TESTS.count}]"
    else
        $stderr.print "\r\e[91m❯\e[0m [#{t}] Completed [#{i + 1}/#{TESTS.count}]"
        if FLAGS[:failfast]
            $stderr.print "\n"
            die "[#{t}] FAILED"
        end
    end
end
$stderr.print "\n"

if passed == TESTS.count
    info "OK"
else
    err "Passed: [#{passed}/#{TESTS.count}]"
end
